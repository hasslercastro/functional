
Funciones anonimas

Funciones pasadas por parametro
	
def myFun2(fx : Int => Int) : Int = Int = fx.andThen(_+1)

Currying
	
def sum(x : Int)(y: Int) : Int = x + y

Recursividad

 def fact( n : Long) : Long = n match {
     |      case 0L => 1L
     |      case 1L => 1L
     |      case n => n * fact(n-1)
     | }

TailRecursion

 

Listas

def sum_1(l: List[Int]) : List[Int] = l match {
	case Nil => Nil
	case List(x) => List(x + 1)
        case h :: t => (h + 1) :: sum_1(t)
}


list match { case List(a, b, c, rest @ _*) => (a + b + c,  rest) } //_* recibe el resto de argumentos que tenga la lista, 3 o más el @ asigna ese resto a la variable rest


Tener mi objeto sin tener que escribir new antes, y defino apply y unapply para poderlo usar en mi match además tener en cuenta que los crea privados por defecto, por eso agrego val para que me cree internamente un par de getters
	class Person(val name : String, val age : Int)
	object Person{
		def apply(name : String , age : int): Person = new Person(name, age)
		def unapply(person : Person) : Option[(person.name, person.age)]

	}

Todo lo anterior se ve resumido por un case class , además debe ser final pues es una buena practica y la clase no debería ser sobreescrita
final case class Person(name : String, age : Int)